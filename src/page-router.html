<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-selector/iron-selectable.html">
<link rel="import" href="../neon-animation/neon-animation-runner-behavior.html">
<link rel="import" href="../neon-animation/neon-animatable-behavior.html">
<link rel="import" href="../neon-animation/animations/opaque-animation.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../iron-selector/iron-selectable.html">

<script src="../page/page.js"></script>


<dom-module id="page-route">
	<style>
		:host {
			display: block;
			position: absolute;
		}
	</style>
	<template>
		<content></content>
	</template>
	<script>
/*global Polymer, page, document */
(function () {
	"use strict";
	// HACK: this is to keep jslint quiet
	var polymer = Polymer;

	polymer({
		is: 'page-route',
		properties: {
			path: String,
			element: String,
			import: String
		},
		behaviors: [
			Polymer.NeonAnimatableBehavior
		]

	});
}());
</script>
</dom-module>

<dom-module id="page-router">
	<template>
		<content></content>
	</template>
	<script>
/*global Polymer, page, document */
(function () {
	"use strict";
	// HACK: this is to keep jslint quiet
	var polymer = Polymer,
		importedURIs = {};

	polymer({
		is: 'page-router',
		behaviors: [
			Polymer.IronResizableBehavior,
			Polymer.IronSelectableBehavior,
			Polymer.NeonAnimationRunnerBehavior
		],
		properties: {

		},
		_previousRoute: null,
		_currentRoute: null,
		observers: [
			'_selectedChanged(selected)'
		],
		listeners: {
			'neon-animation-finish': '_onNeonAnimationFinish'
		},

		ready: function () {
			this.attrForSelected = "path";
		},

		attached: function () {
			console.log('attached');
			this.start();
		},


		start: function () {
			var routes,
				route,
				i;


			// Catch-all middleware to notify other we are changing route
			page('*', this._routeChanging.bind(this));

			routes = Polymer.dom(this).querySelectorAll('page-route');

			console.log(routes);

			for (i = 0; i < routes.length; i += 1) {
				route = routes[i];
				page(route.getAttribute('path'), this._changeRoute.bind(this, route));
			}

			page.start({
				hashbang: true
			});
			console.log('router initialized');
		},

		show: function (path) {
			page.show(path);
		},

		hasRoute: function (path) {
			var route = Polymer.dom(this).querySelector('page-route[path="' + path + '"]');
			return !!route;
		},

		addAndShowRoute: function (route) {
			console.log('add route');
			var newRouteElement = document.createElement('page-route');
			newRouteElement.setAttribute('path', route.path);
			newRouteElement.setAttribute('element', route.element);
			if (route.import) {
				newRouteElement.setAttribute('import', route.import);
			}
			Polymer.dom(this).appendChild(newRouteElement);
			page(route.path, this._changeRoute.bind(this, newRouteElement));
			page.stop();
			page.start({
				dispatch: false,
				hashbang: true
			});
			page.show(route.path);

		},

		/**
		 * page.js middleware registered as first catch-all rule.
		 * It allows to notify others that we are changing route, enabling them
		 * to possible dynamically add a route.
		 */
		_routeChanging: function (context, next) {

			var evt = this.fire(
				'route-changing',
				{
					context: context
				},
				{
					bubbles: false,
					cancelable: true
				}
			);

			if (!evt.defaultPrevented) {
				next();
			} else {
				context.handled = true;
			}
		},

		_changeRoute: function (newRoute, context, next) {
			var importUri;
			console.log('change route', arguments);
			if (newRoute !== this._currentRoute) {
				importUri = newRoute.getAttribute('import');
				if (importUri) {
					this._importAndActivate(newRoute, importUri, context);
				} else {
					this._activateElement(newRoute, newRoute.getAttribute('element'), context);
				}

			} else {
				// Same route, so simply update the model
				newRoute.firstElementChild.params = context.params;
				this.fire('route-changed', {}, { bubbles: false, cancelable: true});
				newRoute.fire('route-changed', {}, { bubbles: false, cancelable: true});
				console.log('route did not change, updating model.');
			}

		},
		_importAndActivate: function (route, importUri, context) {
			var router = this,
				importLink;

			function importLoadedCallback(e) {
				importLink.loaded = true;
				console.log('route imported', route);
				router._activateElement(route, route.getAttribute('element'), context);
			}

			function importErrorCallback(e) {
				var
					detail = {
						route: route
					},
					options = {
						bubbles : false,
						cancelable: true
					};
				importLink.notFound = true;
				router.fire('import-error', detail, options);
				route.fire('import-error', detail, options);
				console.log('import error', e, route);
			}

			if (!importedURIs.hasOwnProperty(importUri)) {
				importLink = document.createElement('link');
				importLink.setAttribute('rel', 'import');
				importLink.setAttribute('href', importUri);
				importLink.setAttribute('async', 'async');
				importLink.addEventListener('load', importLoadedCallback);
				importLink.addEventListener('error', importErrorCallback);
				importLink.loaded = false;
				document.head.appendChild(importLink);
				importedURIs[importUri] = importLink;
			} else {
				// previously imported. this is an async operation and may not be complete yet.
				console.log('route already imported', route);
				importLink = importedURIs[importUri];
				if (importLink.notFound) {
					importErrorCallback(null, route);
				} else if (!importLink.loaded) {
					importLink.addEventListener('load', importLoadedCallback);
					importLink.addEventListener('error', importErrorCallback);
				} else {
					this._activateElement(route, route.getAttribute('element'), context);
				}
			}
		},

		_activateElement: function (route, routeElementName, context) {
			var routeElement = document.createElement(routeElementName);

			routeElement.params = context.params;
			route.appendChild(routeElement);
			this.selected = route.path;

			this.fire('route-changed', {}, { bubbles: false, cancelable: true});
			route.fire('route-changed', {}, { bubbles: false, cancelable: true});

			this._previousRoute = this._currentRoute;
			this._currentRoute =  route;
		},

		//
		// Code copied from neon-animated-page, to implement animation when changing route
		//
		_selectedChanged: function (selected) {
			var selectedPage = this.selectedItem,
				oldPage = this._prevSelected || false;

			this._prevSelected = selectedPage;
			// on initial load and if animateInitialSelection is negated, simply display selectedPage.
			if (!oldPage && !this.animateInitialSelection) {
				this._completeSelectedChanged();
				return;
			}
			// insert safari fix.
			this.animationConfig = [{
				name: 'opaque-animation',
				node: selectedPage
			}];
			// configure selectedPage animations.
			if (this.entryAnimation) {
				this.animationConfig.push({
					name: this.entryAnimation,
					node: selectedPage
				});
			} else {
				if (selectedPage.getAnimationConfig) {
					this.animationConfig.push({
						animatable: selectedPage,
						type: 'entry'
					});
				}
			}
			// configure oldPage animations iff exists.
			if (oldPage) {
				// cancel the currently running animation if one is ongoing.
				if (oldPage.classList.contains('neon-animating')) {
					this._squelchNextFinishEvent = true;
					this.cancelAnimation();
					this._completeSelectedChanged();
				}
				// configure the animation.
				if (this.exitAnimation) {
					this.animationConfig.push({
						name: this.exitAnimation,
						node: oldPage
					});
				} else {
					if (oldPage.getAnimationConfig) {
						this.animationConfig.push({
							animatable: oldPage,
							type: 'exit'
						});
					}
				}
				// display the oldPage during the transition.
				oldPage.classList.add('neon-animating');
			}
			// display the selectedPage during the transition.
			selectedPage.classList.add('neon-animating');
			// actually run the animations.
			if (this.animationConfig.length > 1) {
				// on first load, ensure we run animations only after element is attached.
				if (!this.isAttached) {
					this.async(function () {
						this.playAnimation(null, {
							fromPage: null,
							toPage: selectedPage
						});
					});
				} else {
					this.playAnimation(null, {
						fromPage: oldPage,
						toPage: selectedPage
					});
				}
			} else {
				this._completeSelectedChanged(oldPage, selectedPage);
			}
		},

		_completeSelectedChanged: function (oldPage, selectedPage) {
			var node, index = 0, nodes, child, childToRemove;
			if (selectedPage) {
				selectedPage.classList.remove('neon-animating');
			}
			if (oldPage) {
				oldPage.classList.remove('neon-animating');
			}
			if (!selectedPage || !oldPage) {
				nodes = Polymer.dom(this.$.content).getDistributedNodes();
				for (index = 0; node = nodes[index]; index += 1) {
					node.classList && node.classList.remove('neon-animating');
				}
			}

			// Removes previous route children only when animation finished.
			if (this._previousRoute) {
				child = this._previousRoute.firstChild;
				while (child) {
					childToRemove = child;
					child = child.nextSibling;
					this._previousRoute.removeChild(childToRemove);
				}
			}
			this.async(this.notifyResize);
		},

		_onNeonAnimationFinish: function (event) {
			if (this._squelchNextFinishEvent) {
				this._squelchNextFinishEvent = false;
				return;
			}
			this._completeSelectedChanged(event.detail.fromPage, event.detail.toPage);
			console.log('_onNeonAnimationFinish');
		}



	});
}());
</script>
</dom-module>
