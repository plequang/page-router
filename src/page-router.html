<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-selector/iron-selectable.html">
<link rel="import" href="../neon-animation/neon-animation-runner-behavior.html">
<link rel="import" href="../neon-animation/neon-animatable-behavior.html">
<link rel="import" href="../neon-animation/animations/opaque-animation.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../iron-selector/iron-selectable.html">

<script src="../page/page.js"></script>


<dom-module id="page-route">
	<style>
		:host {
			display: block;
			position: absolute;
		}
	</style>
	<template>
		<content></content>
	</template>
	<script>
/*global Polymer, page, document */
(function () {
	"use strict";
	// HACK: this is to keep jslint quiet
	var polymer = Polymer;

	polymer({
		is: 'page-route',
		properties: {
			path: String,
			element: String,
			import: String
		},
		behaviors: [
			Polymer.NeonAnimatableBehavior
		]

	});
}());
</script>
</dom-module>

<dom-module id="page-router">
	<template>
		<content></content>
	</template>
	<script>
/*global Polymer, page, document */
(function () {
	"use strict";
	// HACK: this is to keep jslint quiet
	var polymer = Polymer;

	polymer({
		is: 'page-router',
		behaviors: [
			Polymer.IronResizableBehavior,
			Polymer.IronSelectableBehavior,
			Polymer.NeonAnimationRunnerBehavior
		],
		properties: {

		},
		_previousRoute: null,
		_currentRoute: null,
		observers: [
			'_selectedChanged(selected)'
		],
		listeners: {
			'neon-animation-finish': '_onNeonAnimationFinish'
		},
		_selectedChanged: function (selected) {
			var selectedPage = this.selectedItem,
				oldPage = this._prevSelected || false;

			this._prevSelected = selectedPage;
			// on initial load and if animateInitialSelection is negated, simply display selectedPage.
			if (!oldPage && !this.animateInitialSelection) {
				this._completeSelectedChanged();
				return;
			}
			// insert safari fix.
			this.animationConfig = [{
				name: 'opaque-animation',
				node: selectedPage
			}];
			// configure selectedPage animations.
			if (this.entryAnimation) {
				this.animationConfig.push({
					name: this.entryAnimation,
					node: selectedPage
				});
			} else {
				if (selectedPage.getAnimationConfig) {
					this.animationConfig.push({
						animatable: selectedPage,
						type: 'entry'
					});
				}
			}
			// configure oldPage animations iff exists.
			if (oldPage) {
				// cancel the currently running animation if one is ongoing.
				if (oldPage.classList.contains('neon-animating')) {
					this._squelchNextFinishEvent = true;
					this.cancelAnimation();
					this._completeSelectedChanged();
				}
				// configure the animation.
				if (this.exitAnimation) {
					this.animationConfig.push({
						name: this.exitAnimation,
						node: oldPage
					});
				} else {
					if (oldPage.getAnimationConfig) {
						this.animationConfig.push({
							animatable: oldPage,
							type: 'exit'
						});
					}
				}
				// display the oldPage during the transition.
				oldPage.classList.add('neon-animating');
			}
			// display the selectedPage during the transition.
			selectedPage.classList.add('neon-animating');
			// actually run the animations.
			if (this.animationConfig.length > 1) {
				// on first load, ensure we run animations only after element is attached.
				if (!this.isAttached) {
					this.async(function () {
						this.playAnimation(null, {
							fromPage: null,
							toPage: selectedPage
						});
					});
				} else {
					this.playAnimation(null, {
						fromPage: oldPage,
						toPage: selectedPage
					});
				}
			} else {
				this._completeSelectedChanged(oldPage, selectedPage);
			}
		},
		_completeSelectedChanged: function (oldPage, selectedPage) {
			var node, index = 0, nodes, child, childToRemove;
			if (selectedPage) {
				selectedPage.classList.remove('neon-animating');
			}
			if (oldPage) {
				oldPage.classList.remove('neon-animating');
			}
			if (!selectedPage || !oldPage) {
				nodes = Polymer.dom(this.$.content).getDistributedNodes();
				for (index = 0; node = nodes[index]; index += 1) {
					node.classList && node.classList.remove('neon-animating');
				}
			}

			// Removes previous route children only when animation finished.
			if (this._previousRoute) {
				child = this._previousRoute.firstChild;
				while (child) {
					childToRemove = child;
					child = child.nextSibling;
					this._previousRoute.removeChild(childToRemove);
				}
			}
			this.async(this.notifyResize);
		},
		_onNeonAnimationFinish: function (event) {
			if (this._squelchNextFinishEvent) {
				this._squelchNextFinishEvent = false;
				return;
			}
			this._completeSelectedChanged(event.detail.fromPage, event.detail.toPage);
			console.log('_onNeonAnimationFinish');
		},

		ready: function () {
			this.attrForSelected = "path";
		},
		_changeRoute: function (path, routeElementName, route, context, next) {
			var routeElement;
			console.log('change route', arguments);
			if (route !== this._currentRoute) {
				routeElement = document.createElement(routeElementName);
				route.appendChild(routeElement);
				this.selected = path;

				this._previousRoute = this._currentRoute;
				this._currentRoute =  route;
			} else {
				console.log('route did not change.');
			}

		},
		init: function () {
			var routes,
				route,
				path,
				routeElementName,
				i;

			routes = Polymer.dom(this).querySelectorAll('page-route');
			console.log(routes);

			for (i = 0; i < routes.length; i += 1) {
				route = routes[i];
				path = route.getAttribute('path');
				routeElementName = route.getAttribute('element');
				page(path, this._changeRoute.bind(this, path, routeElementName, route));
			}
			//page.base('#!');
			page.start({
				hashbang: true
			});
			console.log('router initialized');
		},
		attached: function () {
			console.log('attached');
			this.init();
		}

	});
}());
</script>
</dom-module>
